# 								`java`基础



## super关键字

在继承关系中，子类会自动继承父类中定义的方法，但有时在子类中需要对继承的方法进行一些修改，即对父类的方法进行重写。需要注意的是，在子类中重写的方法需要和父类被重写的方法具有相同的方法名、参数列表以及返回值类型。

当子类重写父类的方法后，子类对象将无法访问父类被重写的方法，为了解决这个问题，在Java中专门提供了一个super关键字用于子类访问父类的成员。例如访问父类的**属性**、**方法**和**构造器**。

1. 我们可以在子类的方法或构造器中。通过使用"super.属性"或"super.方法"的方式，显式的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略"super."
2. 属性：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的
   使用"'super.属性"的方式，表明调用的是父类中声明的属性。(正常情况下不要在子父类中定义同名属性，可以描述的清楚些，进行区分，还有一个重要的原因是属性一般被`private`修饰，这样就不存在继承关系)
3.  方法：当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的
   使用"super.方法"的方式，表明调用的是父类中被重写的方法。
4. 构造器：

   - 我们可以在子类的构造器中显式的使用"super(形参列表)"的方式，调用父类中声明的指定的构造器
   - "super(形参列表)"的使用，必须声明在子类构造器的首行！
   - 我们在类的构造器中，针对于"this(形参列表）"或"super(形参列表）"只能二选一，不能同时出现
   - 在构造器的首行，没有显式的声明"this(形参列表）"或"super(形参列表）"，则默认调用的是父类中空参的构造器：super()
   - 在类的多个构造器中，至少有一个类中的构造器使用了"super(形参列表)"，调用父类中的构造器，因为内存中是先加载父类再加载子类


> 类的构造器中至少有一个构造器使用了"super(形参列表)"，也就是说如果有N个构造器最多有N-1个构造器调用"'this(形参列表)"不可能所有的构造器都使用"this(形参列表)"，因为这样会导致构造器循环调用

## 子类对象实例化过程

1. 从结果上来看：（继承性）
   子类继承父类以后，就获取了父类中声明的属性或方法。创建子类的对象，在堆空间中，就会加载所有父类中声明的属性
2. 从过程上来看：
   当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器直到调用了`java.lang.Object`类中空参的构造器为止。正因为加载过所有的父类的结构，所以才可以看到内存中有父类中的结构，子类对象才可以考虑进行调用。

> 虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象

## 多态

1. 理解多态性：可以理解为一个事物的多种形态

2. 何为多态性：

   - 对象的多态性：父类的引用指向子类的对象（或者子类的对象赋给父类的引用）

3. 多态的使用：虚拟方法调用

   - 子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚拟方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的

   - 有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。
     总结：编译，看左边；运行，看右边

4. 多态性的使用前提：

   - 类的继承关系
   - 方法的重写

5. 对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边）

6. 多态是编译时行为还是运行时行为？答：运行时行为，因为执行哪个子类的方法在编译期是确定不了的

## 重载和重写区别（编译和运行角度）

1. 重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它们的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。所以：对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”
2. 而对于多态，只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定“

