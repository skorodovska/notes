# 								`java`基础



## 方法的重写

1. 重写：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作

2. 应用：重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实执行的是子类重写父类的方法。

3. 重写的规定：

   ```java
   方法的声明： 权限修饰符 返回值类型 方法名(形参列表）throws 异常的类型{
   //方法体
   }
   ```

   约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法

   - 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同
   - 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符
     - 特殊情况：子类不能重写父类中声明为private权限的方法
   - 返回值类型：
     - 父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void
     - 父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类
     - 父类被重写的方法的返回值类型为基本数据类型(例如：int)，则子类重写方法的返回值类型必须是相同的基本数据类型(必须也是int)
   - 子类重写的方法抛出的异常不大于父类被重写方法抛出的异常类型

   >
   >子类和父类的同名同参数的方法要么声明为非static的(考虑重写)，要么都声明为非static的(不考虑重写)

## super关键字

在继承关系中，子类会自动继承父类中定义的方法，但有时在子类中需要对继承的方法进行一些修改，即对父类的方法进行重写。需要注意的是，在子类中重写的方法需要和父类被重写的方法具有相同的方法名、参数列表以及返回值类型。

当子类重写父类的方法后，子类对象将无法访问父类被重写的方法，为了解决这个问题，在Java中专门提供了一个**super关键字用于子类访问父类的成员**。例如访问父类的**属性**、**方法**和**构造器**。

1. 我们可以在子类的方法或构造器中。通过使用"super.属性"或"super.方法"的方式，显式的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略"super."
2. 属性：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的
   使用"'super.属性"的方式，表明调用的是父类中声明的属性。(正常情况下不要在子父类中定义同名属性，可以描述的清楚些，进行区分，还有一个重要的原因是属性一般被`private`修饰，这样就不存在继承关系)
3.  方法：当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的
   使用"super.方法"的方式，表明调用的是父类中被重写的方法。
4. 构造器：

   - 我们可以在子类的构造器中显式的使用"super(形参列表)"的方式，调用父类中声明的指定的构造器
   - "super(形参列表)"的使用，必须声明在子类构造器的首行！
   - 我们在类的构造器中，针对于"this(形参列表）"或"super(形参列表）"只能二选一，不能同时出现
   - 在构造器的首行，没有显式的声明"this(形参列表）"或"super(形参列表）"，则默认调用的是父类中空参的构造器：super()
   - 在类的多个构造器中，至少有一个类中的构造器使用了"super(形参列表)"，调用父类中的构造器，因为内存中是先加载父类再加载子类


> 类的构造器中至少有一个构造器使用了"super(形参列表)"，也就是说如果有N个构造器最多有N-1个构造器调用"'this(形参列表)"不可能所有的构造器都使用"this(形参列表)"，因为这样会导致构造器循环调用

## 子类对象实例化过程

1. 从结果上来看：（继承性）
   子类继承父类以后，就获取了父类中声明的属性或方法。创建子类的对象，在堆空间中，就会加载所有父类中声明的属性
2. 从过程上来看：
   当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器直到调用了`java.lang.Object`类中空参的构造器为止。正因为加载过所有的父类的结构，所以才可以看到内存中有父类中的结构，子类对象才可以考虑进行调用。

> 虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象

## 多态

1. 理解多态性：可以理解为一个事物的多种形态
2. 何为多态性：

   - 对象的多态性：父类的引用指向子类的对象（或者子类的对象赋给父类的引用）
3. 多态的使用：虚拟方法调用

   - 子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚拟方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的

   - 有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。
     总结：编译，看左边；运行，看右边
4. 多态性的使用前提：

   - 类的继承关系
   - 方法的重写
5. 对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边）
6. 不能调用子类特有的方法
6. 多态是编译时行为还是运行时行为？答：运行时行为，因为执行哪个子类的方法在编译期是确定不了的

## 重载和重写区别（编译和运行角度）

1. 重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它们的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。所以：对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”
2. 而对于多态，只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定“

## instanceof操作符

```java
Person p1 = new Man();
Person p2 = new Woman();
//调用Man类特有的方法报错
p1.earnMoney();
//强转后不报错
Man man = (Man)p1;
man.earnMoney();
```

分析：有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用，可以使用强制类型转换符向下转型`Man man = (Man)p1;`

a instanceof A：判断对象a是否是类A的实例，如果是返true；如果不是返回false。

使用情境：为了避免在向下转型时出现ClassCastException的异常，我们在向下转型之前，先进行instanceof的判断，一旦返回true，就进行向下转型。如果返回false，不进行向下转型。

## static

static关键词的使用

1. static：静态的

2. static可以用来修饰：属性、方法、代码块、内部类

3. 使用static修饰属性：静态变量（或类变量）

   1. 属性，按照是否使用static修饰，分为静态变量 VS 非静态变量（实例变量）

      1. 非静态变量：我们创建了类的多个对象，每个对象都独立的拥有一套类中的非静态变量，当修改其中一个对象的非静态变量时，不会导致其他对象中同样的属性值修改。
      2. 静态变量：我们创建了类的多个对象，多个对象共享同一个静态变量，当通过某一个对象修改静态变量时，会导致其他对象调用此对象时，静态变量是修改过了的。

   2. static修饰属性的其他说明

      1. 静态变量随着类的加载而加载，可以通过”类.静态变量“的方式进行调用。

      2. 静态变量的加载要早于对象的创建。

      3. 由于类只加载一次，则静态变量在内存中也只会存在一份，存在方法区的静态域中。

      4. |      | 类变量 | 实例变量 |
         | ---- | ------ | -------- |
         | 类   | yes    | no       |
         | 对象 | yes    | yes      |

   3. 静态属性举例

      1. `System.out`
      2. `Math.PI`

4. 使用static修饰方法：静态方法

   1. 随着类的加载而加载，可以通过“类.方法”的方式调用

   2. 静态方法中只能调用静态的方法或属性，非静态方法中，既可以调用静态属性或方法，也可以调用非静态属性或方法

   3. |      | 静态方法 | 非静态方法 |
      | ---- | -------- | ---------- |
      | 类   | yes      | no         |
      | 对象 | yes      | yes        |

5. static注意点

   1. 在静态方法内，不可以使用this关键字、super关键字。
   2. 关于静态属性和静态方法的使用，大家都从生命周期的角度来理解。

6. 开发中，如何确定一个属性是否要声明为static的？

   1. 属性是可以被多个对象共享的，不会随着对象不同而不同的。

7. 开发中，如何确定一个方法是否要声明为static的？

   1. 操作静态属性的方法，通常设置为static的。
   2. 工具类中的方法，习惯上声明为static的，因为没有必要创建对象
